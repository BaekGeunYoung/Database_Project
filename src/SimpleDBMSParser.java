/* Generated By:JavaCC: Do not edit this line. SimpleDBMSParser.java */
import com.sleepycat.je.*;

import java.io.File;
import java.io.UnsupportedEncodingException;
import java.util.*;

public class SimpleDBMSParser implements SimpleDBMSParserConstants {
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SELECT = 4;
  public static final int PRINT_INSERT = 5;
  public static final int PRINT_DELETE = 6;
  public static final int PRINT_SHOW_TABLES = 7;

  public static int table_num = 0;
  public static int table_id = 0;
  public static int pkDefMark = 0;
  public static Environment myDbEnvironment = null;
  public static Database myDatabase = null;

  public static Cursor cursor = null;
  public static DatabaseEntry key = new DatabaseEntry();
  public static DatabaseEntry value = new DatabaseEntry();

  public static String[] column_name;
  public static String[] type;
  public static String[] not_null;
  public static String[] isnull;
  public static String[] primary_key;
  public static String[] foreign_key;
  public static String[] key_info;

  public static String columnList = new String();
  public static String typeList = new String();
  public static String notnullList = new String();
  public static String pkList = new String();
  public static String fkList = new String();
  public static String refList = new String();
  public static String refTable = new String();

  public static void main(String args[]) throws UnsupportedEncodingException, ParseException, CustomException.TempException
  {

    EnvironmentConfig envConfig = new EnvironmentConfig();
    DatabaseConfig dbConfig = new DatabaseConfig();

    envConfig.setAllowCreate(true);
    myDbEnvironment = new Environment(new File("db/"), envConfig);

    dbConfig.setAllowCreate(true);
    myDatabase = myDbEnvironment.openDatabase(null, "sampleDatabase", dbConfig);

        updateDbNumber();

    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2017-17450> ");

    while (true)
    {
        try
        {
          parser.command();
        }
        catch(CustomException.TempException e){
            System.out.print("DB_2017-17450> ");
            System.out.println(e);
            SimpleDBMSParser.ReInit(System.in);
            System.out.print("DB_2017-17450> ");

        }
        catch (Exception e)
        {
            System.out.println("DB_2017-17450> Syntax error");
            SimpleDBMSParser.ReInit(System.in);
            System.out.print("DB_2017-17450> ");
        }
    }
  }

  public static int findTableNumber(String tableValue) throws UnsupportedEncodingException
  {
          cursor = myDatabase.openCursor(null, null);
          cursor.getFirst(key, value, LockMode.DEFAULT);

          String keyString = new String();
          String valueString = new String();

          if(key.getData() == null) {
              cursor.close();
              return -1;
          }
          do{
                        keyString = new String(key.getData(), "UTF-8");
                        valueString = new String(value.getData(), "UTF-8");
                        if(keyString.startsWith("table") && valueString.equals(tableValue)) {
                           cursor.close();
                           return Integer.parseInt(keyString.substring(5, keyString.length()));
                        }
          } while(cursor.getNext(key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS);

//          System.out.println(tableValue);
          cursor.close();
          return -1;
  }

  public static void updateDbNumber() throws UnsupportedEncodingException
  {
      table_num = 0;
      table_id = 0;
      cursor = myDatabase.openCursor(null, null);
          cursor.getFirst(key, value, LockMode.DEFAULT);
          if(key.getData() == null) {
                cursor.close();
            return;
          }
          do {
                String keyString = new String(key.getData(), "UTF-8");
                String valueString = new String(value.getData(), "UTF-8");
                if(keyString.startsWith("table")) {
                    table_num++;
                        int current_num = Integer.parseInt(keyString.substring(5, keyString.length()));
                        if(current_num + 1 > table_id) table_id = current_num + 1;
                }
          } while(cursor.getNext(key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS);
//	  System.out.println("Current table_num: " + table_num);
//	  System.out.println("Current table_id: " + table_id);
          cursor.close();
  }

  public static boolean DuplicateColumnDefError(String list) throws UnsupportedEncodingException
  {
    String[] colList = list.split(",",-1);
    for(int i = 0 ; i < colList.length ; i++) {
                for(int j = i+1 ; j < colList.length ; j++) {
                        if(colList[i].equals(colList[j])) {
                                System.out.println("DB_2017-17450> Create table has failed: column definition is duplicated");
                            return true;
                        }
                }
    }
        return false;
  }

  public static boolean DuplicatePrimaryKeyColumnError(String list) throws UnsupportedEncodingException
  {
    String[] pkList = list.split(",", -1);
    for(int i = 0 ; i < pkList.length ; i++) {
                for(int j = i+1 ; j < pkList.length ; j++) {
                        if(pkList[i].equals(pkList[j])) {
                                System.out.println("DB_2017-17450> Create table has failed: duplicated column name in primary key definition");
                            return true;
                        }
                }
    }
        return false;
  }

  public static boolean DuplicatePrimaryKeyDefError(int mark) {
        if(mark > 1) {
                System.out.println("DB_2017-17450> Create table has failed: primary key definition is duplicated");
                return true;
        }

        return false;
  }

  public static boolean ReferenceTypeError(String columnList, String typeList, String fkList, String refList, String refTable) throws UnsupportedEncodingException
  {
      if(fkList.equals("")) return false;

    String[] type_list = typeList.split(",", -1);
    String[] column_list = columnList.split(",", -1);

    String[] fkEachList = fkList.split(" ", -1);
    String[] refTableList = refTable.split(",", -1);
    String[] refEachList = refList.split(" ", -1);

    for(int j = 0 ; j < refTableList.length ; j++) {
        String[] list1 = fkEachList[j].split(",", -1);
        String[] list2 = refEachList[j].split(",", -1);

        //column ���� ��ġ���� �˻�
        if (list1.length != list2.length) {
            System.out.println("DB_2017-17450> Create table failed: foreign key references wrong type 1");
            return true;
        }

        //type ��ġ ���� �˻�
        int targetNum = findTableNumber(refTableList[j]);
        String refColList = new String();
        String[] refCol;

        String refTypeList = new String();
        String[] refType;

        String colKey = "column" + targetNum;
        String typeKey = "type" + targetNum;

        DatabaseEntry theKey = new DatabaseEntry(colKey.getBytes("UTF-8"));
        DatabaseEntry theData = new DatabaseEntry();

        if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
            refColList = new String(theData.getData(), "UTF-8");
            refCol = refColList.split(",", -1);
        } else {
            System.out.println("No record found for key :" + theKey);
            System.out.println("DB_2017-17450> Create table failed: foreign key references wrong type");
            return true;
        }

        theKey = new DatabaseEntry(typeKey.getBytes("UTF-8"));
        theData = new DatabaseEntry();

        if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
            refTypeList = new String(theData.getData(), "UTF-8");
            refType = refTypeList.split(",", -1);
        } else {
            System.out.println("No record found for key :" + theKey);
            System.out.println("DB_2017-17450> Create table failed: foreign key references wrong type");
            return true;
        }

        for (int i = 0; i < list2.length; i++) {
            if (!type_list[Arrays.asList(column_list).indexOf(list1[i])].equals(refType[Arrays.asList(refCol).indexOf(list2[i])])) {
                System.out.println("DB_2017-17450> Create table failed: foreign key references wrong type 2");
                return true;
            }
        }
    }
    return false;
  }

  public static boolean ReferenceNonPrimaryKeyError(String refTable, String refList) throws UnsupportedEncodingException
  {
    if(refTable.equals("")) return false;

    String[] refTableList = refTable.split(",", -1);
    String[] refColList = refList.split(" ", -1);

    for(int i = 0; i < refTableList.length ; i++) {
        int targetNum = findTableNumber(refTableList[i]);
        String pKey = "primary" + targetNum;

        DatabaseEntry theKey = new DatabaseEntry(pKey.getBytes("UTF-8"));
        DatabaseEntry theData = new DatabaseEntry();

        String pkStr = new String();
        String[] pk_list;

        if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
            pkStr = new String(theData.getData(), "UTF-8");
            pk_list = pkStr.split(",", -1);
        } else {
            System.out.println("No record found for key :" + theKey);
            System.out.println("DB_2017-17450> Create table has failed: foreign key references non primary key column");
            return true;
        }

        String[] ref_list = refColList[i].split(",", -1);
        Arrays.sort(ref_list);
        Arrays.sort(pk_list);

        if (!Arrays.equals(ref_list, pk_list)) {
            System.out.println("DB_2017-17450> Create table has failed: foreign key references non primary key column");
            return true;
        }
    }
    return false;
  }

  public static boolean ReferenceColumnExistenceError(String refList, String refTable) throws UnsupportedEncodingException
  {
    if(refTable.equals("")) return false;

    String[] refTableList = refTable.split(",",-1);
    String[] refColList = refList.split(" ",-1);

    for(int j = 0 ; j < refTableList.length ; j++) {
        int targetNum = findTableNumber(refTableList[j]);
        String colKey = "column" + targetNum;

        DatabaseEntry theKey = new DatabaseEntry(colKey.getBytes("UTF-8"));
        DatabaseEntry theData = new DatabaseEntry();

        String colStr = new String();
        String[] col_list;

        if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
            colStr = new String(theData.getData(), "UTF-8");
            col_list = colStr.split(",", -1);
        } else {
            System.out.println("No record found for key :" + theKey);
            System.out.println("DB_2017-17450> Create table has failed: foreign key references non existing column");
            return true;
        }

        String[] ref_list = refColList[j].split(",", -1);

        for (int i = 0; i < ref_list.length; i++) {
            if (!Arrays.asList(col_list).contains(ref_list[i])) {
                System.out.println("DB_2017-17450> Create table has failed: foreign key references non existing column");
                return true;
            }
        }
    }

    return false;
  }

  public static boolean ReferenceTableExistenceError(String refTable) throws UnsupportedEncodingException
  {
      if(refTable.equals("")) return false;

          cursor = myDatabase.openCursor(null, null);
          cursor.getFirst(key, value, LockMode.DEFAULT);

          if(key.getData() == null) {
                 cursor.close();
                 System.out.println("DB_2017-17450> Create table has failed: foreign key references non existing table");
             return true;
          }

          String[] refTableList = refTable.split(",", -1);
          for(int i = 0 ; i < refTableList.length ; i++) {
              do {
                  String keyString = new String(key.getData(), "UTF-8");
                  String valueString = new String(value.getData(), "UTF-8");

                  if (keyString.startsWith("table") && valueString.equals(refTableList[i])) {
                      cursor.close();
                      return false;
                  }
              } while (cursor.getNext(key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS);
          }
          cursor.close();
          System.out.println("DB_2017-17450> Create table has failed: foreign key references non existing table");
      return true;
  }

  public static boolean NonExistingColumnDefError(String columnList, String keyList) throws UnsupportedEncodingException
  {
    if(keyList.equals("")) return false;

    String[] key_list = keyList.split(",|\\s", -1);
    String[] column_list = columnList.split(",", -1);
    int r = 0;
    for(int i = 0 ; i < key_list.length ; i++) {
        r = 0;
                for(int j = 0 ; j < column_list.length ; j++) {
                        if(key_list[i].equals(column_list[j])) r = 1;
                }
                if(r == 0) {
                        System.out.println("DB_2017-17450> Create table failed: '" + key_list[i] + "' does not exist in column definition");
                        return true;
                }
    }
    return false;
  }

  public static boolean TableExistenceError(String table_value) throws UnsupportedEncodingException
  {
          cursor = myDatabase.openCursor(null, null);
          cursor.getFirst(key, value, LockMode.DEFAULT);
          if(key.getData() == null) {
                 cursor.close();
             return false;
          }
          do {
                String keyString = new String(key.getData(), "UTF-8");
                String valueString = new String(value.getData(), "UTF-8");

                if(keyString.startsWith("table") && valueString.equals(table_value)) {
                        System.out.println("DB_2017-17450> Create table has failed: table with the same name already exists");
                    cursor.close();
                    return true;
                }
          } while(cursor.getNext(key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS);

          cursor.close();
          return false;
  }

  public static boolean CharLengthError(String typeList) throws UnsupportedEncodingException
  {
    String[] list = typeList.split(",", -1);

    for(int i = 0 ; i < list.length ; i++) {
                if(list[i].startsWith("char")) {
                        if(Integer.parseInt(list[i].substring(5,list[i].length() - 1)) < 1) {
                                System.out.println("DB_2017-17450> Create table has failed: Char length should be over 0");
                                return true;
                        }
                }
    }

    return false;
  }

  public static void CreateTableSuccess(String table_name) throws UnsupportedEncodingException
  {
    System.out.println("DB_2017-17450> '" + table_name + "' table is created");
  }

  public static boolean DropReferencedTableError(String table_name) throws UnsupportedEncodingException
  {
          cursor = myDatabase.openCursor(null, null);
          cursor.getFirst(key, value, LockMode.DEFAULT);
          if(key.getData() == null) {
                 cursor.close();
                 System.out.println("there is no any data");
             return true;
          }
          do {
                String keyString = new String(key.getData(), "UTF-8");
                String valueString = new String(value.getData(), "UTF-8");

                if(keyString.startsWith("refTable") && valueString.contains(table_name)) {
                        System.out.println("DB_2017-17450> Drop table has failed: '" + table_name + "' is referenced by other table");
                    cursor.close();
                    return true;
                }
          } while(cursor.getNext(key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS);

          cursor.close();
          return false;
  }

  public static void DropSuccess(String table_name) {
        System.out.println("DB_2017-17450> '" + table_name + "' table is dropped");
  }

  public static void printMessage(int q)
  {
    System.out.print("DB_2017-17450> ");
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
        System.out.println("Syntax error");
        break;
      case PRINT_CREATE_TABLE:
        System.out.println("\u005c'CREATE TABLE\u005c' requested");
        break;
      case PRINT_DROP_TABLE:
        System.out.println("\u005c'DROP TABLE\u005c' requested");
        break;
      case PRINT_DESC:
        System.out.println("\u005c'DESC\u005c' requested");
        break;
      case PRINT_INSERT:
        System.out.println("\u005c'INSERT\u005c' requested");
        break;
      case PRINT_DELETE:
        System.out.println("\u005c'DELETE\u005c' requested");
        break;
      case PRINT_SELECT:
        System.out.println("\u005c'SELECT\u005c' requested");
        break;
      case PRINT_SHOW_TABLES:
        System.out.println("\u005c'SHOW TABLES\u005c' requested");
        break;
    }
    System.out.print("DB_2017-17450> ");
  }

  static final public void command() throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
    case DROP_TABLE:
    case DESC:
    case SHOW_TABLES:
    case SELECT:
    case INSERT_INTO:
    case DELETE_FROM:
      queryList();
      break;
    case EXIT:
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
          if(myDatabase != null) myDatabase.close();
          if(myDbEnvironment != null) myDbEnvironment.close();
      System.exit(0);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void queryList() throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    label_1:
    while (true) {
      query();
      System.out.print("DB_2017-17450> ");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE_TABLE:
      case DROP_TABLE:
      case DESC:
      case SHOW_TABLES:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  static final public void query() throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
      createTableQuery();
        table_num++;
        table_id++;
      break;
    case DROP_TABLE:
      dropTableQuery();
            table_num--;
      break;
    case DESC:
      descQuery();
      break;
    case SELECT:
      selectQuery();
      break;
    case INSERT_INTO:
      insertQuery();
      break;
    case DELETE_FROM:
      deleteQuery();
      break;
    case SHOW_TABLES:
      showTablesQuery();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void createTableQuery() throws ParseException, UnsupportedEncodingException {
  Token t;
  String create_key;
  String table_value;
    columnList = "";
    typeList = "";
    notnullList = "";
    pkList = "";
    fkList = "";
    refList = "";
    refTable = "";
    pkDefMark = 0;
    jj_consume_token(CREATE_TABLE);
    t = jj_consume_token(LEGAL_IDENTIFIER);
    tableElementList();
    jj_consume_token(SEMICOLON);
    create_key = "table" + table_id;
        table_value = t.toString();

        /*--------Error test---------*/
        if(TableExistenceError(table_value)) { return;}
        if(DuplicateColumnDefError(columnList)) { return;}
        if(CharLengthError(typeList)) { return;}
        if(DuplicatePrimaryKeyDefError(pkDefMark)) { return;}
        if(DuplicatePrimaryKeyColumnError(pkList)) { return;} /*���� �߰��� Error : ���� �̸��� column�� primary key definition�� ������ �����ϴ� ���� �˻���*/
        if(NonExistingColumnDefError(columnList, pkList)) { return;}
        if(NonExistingColumnDefError(columnList, fkList)) { return;}
        if(ReferenceTableExistenceError(refTable)) { return;}
        if(ReferenceColumnExistenceError(refList, refTable)) { return;}
        if(ReferenceTypeError(columnList, typeList, fkList, refList, refTable)) { return;}
        if(ReferenceNonPrimaryKeyError(refTable, refList)) { return;}

        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(table_value.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "column" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(columnList.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "type" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(typeList.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "notnull" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(notnullList.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "primary" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(pkList.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "foreign" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(fkList.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "refTable" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(refTable.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "refList" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry(refList.getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        create_key = "data" + table_id;
        cursor = myDatabase.openCursor(null, null);
        key = new DatabaseEntry(create_key.getBytes("UTF-8"));
        value = new DatabaseEntry("".getBytes("UTF-8"));
        cursor.put(key,value);
        cursor.close();

        //create table success
        CreateTableSuccess(table_value);
  }

  static final public void tableElementList() throws ParseException, UnsupportedEncodingException {
    jj_consume_token(LEFT_PAREN);
    tableElement();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      tableElement();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  static final public void tableElement() throws ParseException, UnsupportedEncodingException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      columnDefinition();
      break;
    case PRIMARY_KEY:
    case FOREIGN_KEY:
      tableConstraintDefinition();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void columnDefinition() throws ParseException, UnsupportedEncodingException {
  String colName = "", typeName = "", notnull = "null";
  Token a, b;
    a = jj_consume_token(LEGAL_IDENTIFIER);
      colName = a.toString();
    typeName = dataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_NULL:
      b = jj_consume_token(NOT_NULL);
      notnull = b.toString();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    if(!columnList.equals("")) columnList += ",";
    if(!typeList.equals("")) typeList += ",";
    if(!notnullList.equals("")) notnullList += ",";

    columnList += colName;
    typeList += typeName;
    notnullList += notnull;
  }

  static final public void tableConstraintDefinition() throws ParseException, UnsupportedEncodingException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY_KEY:
      primaryKeyConstraint();
      break;
    case FOREIGN_KEY:
      referentialConstraint();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void primaryKeyConstraint() throws ParseException, UnsupportedEncodingException {
    jj_consume_token(PRIMARY_KEY);
    pkList = columnNameList();
     pkDefMark++;
  }

  static final public void referentialConstraint() throws ParseException, UnsupportedEncodingException {
    jj_consume_token(FOREIGN_KEY);
    String s1 = columnNameList();
    jj_consume_token(REFERENCES);
    String s2 = jj_consume_token(LEGAL_IDENTIFIER).toString();
    String s3 = columnNameList();

    if(!fkList.equals("")) s1 = " " + s1;
    if(!refTable.equals("")) s2 = "," + s2;
    if(!refList.equals("")) s3 = " " + s3;

    fkList += s1;
    refTable += s2;
    refList += s3;
  }

  static final public String columnNameList() throws ParseException, UnsupportedEncodingException {
  String result = "";
  Token t, s;
    jj_consume_token(LEFT_PAREN);
    t = jj_consume_token(LEGAL_IDENTIFIER);
      result += t.toString();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      s = jj_consume_token(LEGAL_IDENTIFIER);
      result += "," + s.toString();
    }
    jj_consume_token(RIGHT_PAREN);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public String dataType() throws ParseException, UnsupportedEncodingException {
  Token a,b,c,d;
  String result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      a = jj_consume_token(INT);
      {if (true) return a.toString();}
      break;
    case CHAR:
      a = jj_consume_token(CHAR);
      b = jj_consume_token(LEFT_PAREN);
      c = jj_consume_token(INT_VALUE);
      d = jj_consume_token(RIGHT_PAREN);
      {if (true) return a.toString() + b.toString() + c.toString() + d.toString();}
      break;
    case DATE:
      a = jj_consume_token(DATE);
          {if (true) return a.toString();}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public void dropTableQuery() throws ParseException, UnsupportedEncodingException {
  Token t;
  String s;
  int targetNumber;
    jj_consume_token(DROP_TABLE);
    t = jj_consume_token(LEGAL_IDENTIFIER);
    jj_consume_token(SEMICOLON);
          s = t.toString();
          targetNumber = findTableNumber(s);

          if(targetNumber == -1) {
                System.out.println("DB_2017-17450> There is no such table");
                {if (true) return;}
          }

          if(DropReferencedTableError(s)) {if (true) return;}

          String tableKey = "table" + targetNumber;
          String colKey = "column" + targetNumber;
          String typeKey = "type" + targetNumber;
          String nnKey = "notnull" + targetNumber;
          String pKey = "primary" + targetNumber;
          String fKey = "foreign" + targetNumber;
          String refTableKey = "refTable" + targetNumber;
          String refListKey = "refList" + targetNumber;
          String dataKey = "data" + targetNumber;

          DatabaseEntry theKey = new DatabaseEntry(tableKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(colKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(typeKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(nnKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(pKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(fKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(refTableKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(refListKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          theKey = new DatabaseEntry(dataKey.getBytes("UTF-8"));
          myDatabase.delete(null, theKey);

          DropSuccess(s);
  }

  static final public void descQuery() throws ParseException, UnsupportedEncodingException {
  Token t;
  String s;
  String keyString;
  String valueString;
  int targetNumber = 0;
    jj_consume_token(DESC);
    t = jj_consume_token(LEGAL_IDENTIFIER);
    jj_consume_token(SEMICOLON);
          s = t.toString();
          targetNumber = findTableNumber(s);

          /*------------noSuchTableError-----------*/
          if(targetNumber == -1) {
                System.out.println("DB_2017-17450> There is no such table");
                return;
          }

          arrayUpdate(targetNumber);
          descript(s);
  }

  static final public void arrayUpdate(int i) throws ParseException, UnsupportedEncodingException {
                String colKey = "column" + i;
                String typeKey = "type" + i;
                String notnullKey = "notnull" + i;
                String pKey = "primary" + i;
                String fKey = "foreign" + i;

                DatabaseEntry theKey = new DatabaseEntry(colKey.getBytes("UTF-8"));
                DatabaseEntry theData = new DatabaseEntry();

                if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        String List = new String(theData.getData(), "UTF-8");
                        column_name = List.split(",", -1);
            } else {
                System.out.println("No record found for key :" + theKey);
            }

                theKey = new DatabaseEntry(typeKey.getBytes("UTF-8"));
                theData = new DatabaseEntry();

                if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        String List = new String(theData.getData(), "UTF-8");
                        type = List.split(",", -1);
            } else {
                System.out.println("No record found for key :" + theKey);
            }

                theKey = new DatabaseEntry(notnullKey.getBytes("UTF-8"));
                theData = new DatabaseEntry();

                if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        String List = new String(theData.getData(), "UTF-8");
                        not_null = List.split(",", -1);
            } else {
                System.out.println("No record found for key :" + theKey);
            }

                theKey = new DatabaseEntry(pKey.getBytes("UTF-8"));
                theData = new DatabaseEntry();

                if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        String List = new String(theData.getData(), "UTF-8");
                        primary_key = List.split(",", -1);
            } else {
                System.out.println("No record found for key :" + theKey);
            }

                theKey = new DatabaseEntry(fKey.getBytes("UTF-8"));
                theData = new DatabaseEntry();

                if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        String List = new String(theData.getData(), "UTF-8");
                        foreign_key = List.split(",|\\s", -1);
            } else {
                System.out.println("No record found for key :" + theKey);
            }

                isnull = new String[column_name.length];

                int iter;
            for(iter = 0 ; iter < not_null.length ; iter++) {
                        isnull[iter] = (not_null[iter].equals("not null")) ? "N" : "Y";
            }

            if(!primary_key[0].equals("")) {
                for (iter = 0; iter < primary_key.length; iter++) {
                    isnull[Arrays.asList(column_name).indexOf(primary_key[iter])] = "N";
                }
            }
                key_info = new String[column_name.length];
                for(iter = 0 ; iter < key_info.length ; iter++) key_info[iter] = "";
              if(!primary_key[0].equals("")) {
                  for (iter = 0; iter < primary_key.length; iter++) {
                      key_info[Arrays.asList(column_name).indexOf(primary_key[iter])] = "PRI";
                  }
              }

                if(foreign_key.length == 1)
                        if(foreign_key[0].equals("")) {if (true) return;}

                for(iter = 0 ; iter < foreign_key.length ; iter++) {
                        key_info[Arrays.asList(column_name).indexOf(foreign_key[iter])] = "PRI/FOR";
                }
  }

  static final public void descript(String s) throws ParseException, UnsupportedEncodingException {
    System.out.println("--------------------------------------");
    System.out.println("table_name [" + s + "]");
    System.out.printf("%-20s%-20s%-20s%-20s\u005cn","column_name","type","null","key");
    for(int i = 0 ; i < column_name.length ; i++) {
                System.out.printf("%-20s%-20s%-20s%-20s\u005cn",column_name[i],type[i],isnull[i],key_info[i]);
    }
    System.out.println("--------------------------------------");
  }

  static final public void showTablesQuery() throws ParseException, UnsupportedEncodingException {
  String keyString;
  String valueString;
    jj_consume_token(SHOW_TABLES);
    jj_consume_token(SEMICOLON);
          /*------------showtablesNoTable-------------*/

          if(table_num == 0) {
                System.out.println("DB_2017-17450> There is no table");
                {if (true) return;}
          }

          cursor = myDatabase.openCursor(null, null);
          cursor.getFirst(key, value, LockMode.DEFAULT);
          System.out.println("-----------------------");
          if(table_num != 0) {
                  do {
                        keyString = new String(key.getData(), "UTF-8");
                        valueString = new String(value.getData(), "UTF-8");
                        if(keyString.startsWith("table")) System.out.println(valueString);
                  } while(cursor.getNext(key, value, LockMode.DEFAULT) == OperationStatus.SUCCESS);
          }
          System.out.println("-----------------------");
          cursor.close();
  }

  static final public void selectQuery() throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    String[] selectList1, selectList2, selectList3;
    String[] selectedTuple;

    jj_consume_token(SELECT);
    String[] selectList = selectList();
    selectedTuple = tableExpression();
    jj_consume_token(SEMICOLON);


    selectList1 = selectList[0].split("," , -1);
    selectList2 = selectList[1].split("," , -1);
    selectList3 = selectList[2].split(",", -1);
//
//    for(int i = 0 ; i < selectList1.length ; i++) {
//        if (SelectQueryErrorTest.SelectColumnResolveError(selectList1[i], selectList2[i]))
//            throw new CustomException.TempException("");
//    }
    int r = 0;
    if(selectList1[0].equals("*")) {
        selectList1 = attrNameList(selectedTuple[0]);
        r = 1;
    }

      for(int i = 1 ; i < selectedTuple.length ; i++){
          String[] tupleElement = selectedTuple[i].split(",", -1);
          String str2;
          for(int j = 0 ; j < selectList1.length ; j++){
              String content;
              if(r == 0){
                  if(selectList2.length == 0) str2 = "";
                  else str2 = selectList2[j];
                  content = tupleElement[elementIndexSelect(selectedTuple[0].split(",", -1), selectList1[j], str2)];
              }
              else{
                  str2 = "";
                  content = tupleElement[elementIndexWoEx(selectedTuple[0].split(",", -1), selectList1[j], str2)];
              }
          }
      }

    String layout = "+";
    for(int i = 0 ; i < selectList1.length ; i++) layout += "--------------------+";
    System.out.println(layout);
    for(int i = 0 ; i < selectList1.length ; i++){
        if(r == 0) {
            String attrName;
            if (!selectList3[i].equals("")) attrName = selectList3[i];
            else if (!selectList2[i].equals("")) attrName = selectList2[i];
            else attrName = selectList1[i];
            System.out.printf("|%-20s", attrName);
        }
        else System.out.printf("|%-20s", selectList1[i]);
    }
    System.out.println("|");
    System.out.println(layout);
    for(int i = 1 ; i < selectedTuple.length ; i++){
        String[] tupleElement = selectedTuple[i].split(",", -1);
        String str2;
        for(int j = 0 ; j < selectList1.length ; j++){
            String content;
            if(r == 0){
                if(selectList2.length == 0) str2 = "";
                else str2 = selectList2[j];
                content = tupleElement[elementIndexSelect(selectedTuple[0].split(",", -1), selectList1[j], str2)];
            }
            else{
                str2 = "";
                content = tupleElement[elementIndexWoEx(selectedTuple[0].split(",", -1), selectList1[j], str2)];
            }

            content = content.startsWith("'") ? content.substring(1, content.length() - 1) : content;
            System.out.printf("|%-20s", content);
        }
//
//        for(int j = 0 ; j < tupleElement.length ; j++){
//            System.out.printf("|%-20s",tupleElement[j]);
//        }
        System.out.println("|");
    }
    System.out.println(layout);
  }

  static final public String[] attrNameList(String tableNameList) throws UnsupportedEncodingException {
      String[] tableList = tableNameList.split(",", -1);
      ArrayList<String> result = new ArrayList<>();
      for(int i = 0 ; i < tableList.length ; i++){
        result.addAll(Arrays.asList(findColData(tableList[i])));
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] selectList() throws ParseException, UnsupportedEncodingException {
    String[] result = new String[3];
    for(int i = 0 ; i < 3 ; i++) result[i] = "";

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
      jj_consume_token(ALL);
      result[0] = "*";
      break;
    case LEGAL_IDENTIFIER:
      result = selectedColumn();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        String[] selectedCol = selectedColumn();
        result[0] += "," + selectedCol[0];
        result[1] += "," + selectedCol[1];
        result[2] += "," + selectedCol[2];
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

    return result;
  }

  static final public String[] selectedColumn() throws ParseException, UnsupportedEncodingException {
    String[] result = new String[3];
    for(int i = 0 ; i < 3 ; i++) result[i] = "";

    result[0] = jj_consume_token(LEGAL_IDENTIFIER).toString();

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERIOD:
      result[1] = dotColumnName().toString();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      result[2] = jj_consume_token(LEGAL_IDENTIFIER).toString();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }

    return result;
  }

  static final public String[] tableExpression() throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    String[] tableNameList = fromClause();
    String[] tables = tableNameList[0].split(",", -1);
    for(int i = 0 ; i < tables.length ; i++) {
        if (SelectQueryErrorTest.SelectTableExistenceError(tables[i]))
            throw new CustomException.TempException("Selection has failed: '" + tables[i] + "' does not exist");
    }

    String[] selectedTuple = cartesianProduct(tableNameList[0].split(",", -1));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      selectedTuple = whereClause(tableNameList);
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }

    String[] result = new String[selectedTuple.length + 1];
    result[0] = tableNameList[0];
    for(int i = 1 ; i < result.length ; i++) result[i] = selectedTuple[i-1];
    return result;
  }

  static final public String[] fromClause() throws ParseException, UnsupportedEncodingException {
    jj_consume_token(FROM);
    return tableReferenceList();
  }

  static final public String[] tableReferenceList() throws ParseException, UnsupportedEncodingException {
    String[] result = referedTable();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      String[] refered = referedTable();
      result[0] += "," + refered[0];
      result[1] += "," + refered[1];
    }

    return result;
  }

  static final public String[] referedTable() throws ParseException, UnsupportedEncodingException {
    String[] result = new String[2];
    result[0] = jj_consume_token(LEGAL_IDENTIFIER).toString();
    result[1] = "";
    
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      result[1] = jj_consume_token(LEGAL_IDENTIFIER).toString();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }

    return result;
  }

  static final public String[] whereClause(String[] tableName) throws CustomException.TempException, ParseException, UnsupportedEncodingException {
    jj_consume_token(WHERE);
    return booleanValueExpression(tableName);
  }

  static final public String[] booleanValueExpression(String[] tableName) throws CustomException.TempException, ParseException, UnsupportedEncodingException {
    String[] selectedTuple = booleanTerm(tableName);
    String[] s;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_6;
      }
      jj_consume_token(OR);
      s = booleanTerm(tableName);
      selectedTuple = disjunction(selectedTuple, s);
    }

    return selectedTuple;
  }

  static final public String[] disjunction(String[] tupleList1, String[] tupleList2){
      ArrayList<String> result = new ArrayList<String>(Arrays.asList(tupleList1));
      int r = 0;
      for(int i = 0 ; i < tupleList2.length; i++){
          r = 0;
          for(int j = 0 ; j < tupleList1.length ; j++){
              if(tupleList2[i].equals(tupleList1[j])){
                  r = 1;
                  break;
              }
          }
          if(r == 0) result.add(tupleList2[i]);
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] booleanTerm(String[] tableName) throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    String[] selectedTuple = booleanFactor(tableName);
    String[] s;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      s = booleanFactor(tableName);
      selectedTuple = conjunction(selectedTuple, s);
    }

    return selectedTuple;
  }

  static final public String[] conjunction(String[] tupleList1, String[] tupleList2){
      ArrayList<String> result = new ArrayList<>();
      int r = 0;
      for(int i = 0 ; i < tupleList2.length; i++){
          r = 0;
          for(int j = 0 ; j < tupleList1.length ; j++){
              if(tupleList2[i].equals(tupleList1[j])){
                  r = 1;
                  break;
              }
          }
          if(r == 1) result.add(tupleList2[i]);
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] booleanFactor(String[] tableName) throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    int r = 0;
    String[] selectedTuple;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      r = 1;
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }

    selectedTuple = booleanTest(tableName);
    if(r == 1) selectedTuple = negation(tableName[0], selectedTuple);

    return selectedTuple;
  }

  static final public String[] negation(String tableName, String[] selectedTuple) throws ParseException, UnsupportedEncodingException {
      String[] tableNameList = tableName.split(",", -1);
      String[] tupleList = cartesianProduct(tableNameList);
      ArrayList<String> result = new ArrayList<>();
      int r = 0;

      for(int i = 0 ; i < tupleList.length ; i++){
          r = 0;
          for(int j = 0 ; j < selectedTuple.length ; j++){
              if(tupleList[i].equals(selectedTuple[j])){
                  r = 1;
                  break;
              }
          }
          if(r == 0) result.add(tupleList[i]);
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] booleanTest(String[] tableName) throws CustomException.TempException, ParseException, UnsupportedEncodingException {
    String[] selectedTuple;

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case LEGAL_IDENTIFIER:
    case CHAR_STRING:
    case DATE_VALUE:
      selectedTuple = predicate(tableName);
      break;
    case LEFT_PAREN:
      selectedTuple = parenthesizedBooleanExpression(tableName);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

    return selectedTuple;
  }

  static final public String[] parenthesizedBooleanExpression(String[] tableName) throws CustomException.TempException,  ParseException, UnsupportedEncodingException {
    String[] selectedTuple;

    jj_consume_token(LEFT_PAREN);
    selectedTuple = booleanValueExpression(tableName);
    jj_consume_token(RIGHT_PAREN);

    return selectedTuple;
  }

  static final public String[] predicate(String[] tableName) throws CustomException.TempException, ParseException, UnsupportedEncodingException {
    Token t1, t2;
    String s1 = "", s2 = "";
    String[] result = new String[0];
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      t1 = jj_consume_token(LEGAL_IDENTIFIER);
      s1 = t1.toString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD:
        t2 = dotColumnName();
        s2 = t2.toString();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }

      result = comparisonOrNull(tableName, s1, s2);
      break;
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      result = comparisonPredicate(tableName);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

    return result;
  }

  static final public String[] comparisonOrNull(String[] tableName, String s1, String s2) throws CustomException.TempException, ParseException, UnsupportedEncodingException {
    String[] tableNameList = tableName[0].split(",", -1);
    String[] tupleList = cartesianProduct(tableNameList);
    String s;
    Token t;
    String str1 = "", str2 = "";

    int idx = elementIndex(tableName, s1, s2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL_OP:
      s = jj_consume_token(NULL_OP).toString();
      tupleList = filterTuple_null(s, tupleList, idx);
      break;
    case COMP_OP:
      s = jj_consume_token(COMP_OP).toString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_VALUE:
      case CHAR_STRING:
      case DATE_VALUE:
        t = comparableValue();
        tupleList = filterTuple_comp1(s, tupleList, idx, t);
        break;
      case LEGAL_IDENTIFIER:
        str1 = jj_consume_token(LEGAL_IDENTIFIER).toString();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PERIOD:
          str2 = dotColumnName().toString();
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
        int idx2 = elementIndex(tableName, str1, str2);
        tupleList = filterTuple_comp2(s, tupleList, idx, idx2);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }

      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

    return tupleList;
  }

  static final public String[] filterTuple_null(String op, String[] tupleList, int idx) throws CustomException.TempException{
      ArrayList<String> result = new ArrayList<>();

      for(int i = 0 ; i < tupleList.length ; i++){
          String element = tupleList[i].split(",", -1)[idx];
          if(booleanValue(op, element, "")) result.add(tupleList[i]);
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] filterTuple_comp1(String op, String[] tupleList, int idx, Token comparableValue) throws CustomException.TempException {
      String s = comparableValue.toString();
      ArrayList<String> result = new ArrayList<>();

      for(int i = 0 ; i < tupleList.length ; i++){
          String element = tupleList[i].split(",", -1)[idx];
//          System.out.println(element);
          if(booleanValue(op, element, s)) result.add(tupleList[i]);
      }

      return result.toArray(new String[result.size()]);
  }

  static final public boolean booleanValue(String operator, String op1, String op2) throws CustomException.TempException{
      if(!op2.equals("") && WhereErrorTest.WhereIncomparableError(op1, op2)){
          throw new CustomException.TempException("Where clause try to compare incomparable values");
      }

      switch(operator){
          case ">":
              return (op1.compareTo(op2) > 0);
          case "<":
              return (op1.compareTo(op2) < 0);
          case ">=":
              return (op1.compareTo(op2) >= 0);
          case "<=":
              return (op1.compareTo(op2) <= 0);
          case "=":
              return (op1.equals(op2));
          case "!=":
              return (!op1.equals(op2));
          case "is null":
              return (op1.equals("null"));
          case "is not null":
              return (!op1.equals("null"));
          default:
              System.out.println("boolean value calculation error");
              return false;
      }
  }

  static final public String[] filterTuple_comp2(String op, String[] tupleList, int idx1, int idx2) throws CustomException.TempException {
      ArrayList<String> result = new ArrayList<>();

      for(int i = 0 ; i < tupleList.length ; i++){
          String element1 = tupleList[i].split(",", -1)[idx1];
          String element2 = tupleList[i].split(",", -1)[idx2];
          if(booleanValue(op, element1, element2)) result.add(tupleList[i]);
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] filterTuple_comp3(String op, String[] tupleList, int idx, Token comparableValue) throws CustomException.TempException {
    String s = comparableValue.toString();
    ArrayList<String> result = new ArrayList<>();

    for(int i = 0 ; i < tupleList.length ; i++){
        String element = tupleList[i].split(",", -1)[idx];
        if(booleanValue(op, s, element)) result.add(tupleList[i]);
    }

    return result.toArray(new String[result.size()]);
  }

  static final public String[] filterTuple_comp4(String op, String[] tupleList, Token value1, Token value2) throws CustomException.TempException {
    String s1 = value1.toString();
    String s2 = value2.toString();

    if(booleanValue(op, s1, s2)) return tupleList;
    return new String[0];
  }

  static final public int elementIndex(String[] tableNameList, String s1, String s2) throws UnsupportedEncodingException, CustomException.TempException {
      int result = 0;
      int r = 0;
      String[] colList;

      String[] realTableNameList = tableNameList[0].split(",", -1);
      String[] aliasList = tableNameList[1].split(",", -1);
      String[] new_tableNameList = new String[realTableNameList.length];

      for(int i = 0 ; i < realTableNameList.length ; i++){
          new_tableNameList[i] = aliasList[i].equals("") ? realTableNameList[i] : aliasList[i];
      }

      int c = 0;
      if(s2.equals("")){
          for(int i = 0 ; i < realTableNameList.length ; i++){
              colList = findColData(realTableNameList[i]);
              for(int j = 0 ; j < colList.length ; j++){
                  if(s1.equals(colList[j])){
                      r = 1;
                      break;
                  }
                  else result++;
              }
              if(r == 1) break;
          }
          if(r == 0) throw new CustomException.TempException("Where clause try to reference non existing column");

          for(int i = 0 ; i < realTableNameList.length ; i++){
              colList = findColData(realTableNameList[i]);
              for(int j = 0 ; j < colList.length ; j++){
                  if(s1.equals(colList[j])){
                      c++;
                  }
              }
          }
          if(c > 1) throw new CustomException.TempException("Where clause contains ambiguous reference");
      }
      else{
          r = 0;
          for(int i = 0 ; i < new_tableNameList.length ; i++){
              if(s1.equals(new_tableNameList[i])){
                  r = 1;
                  break;
              }
              result += findColData(realTableNameList[i]).length;
          }

          if(r == 0) throw new CustomException.TempException("Where clause try to tables which are not specified");

          String new_s1 = "";
          for(int i = 0 ; i < realTableNameList.length ; i++){
              if(s1.equals(new_tableNameList[i])) new_s1 = realTableNameList[i];
          }

          if(new_s1.equals("")) throw new CustomException.TempException("Where clause try to tables which are not specified");

          colList = findColData(new_s1);
          r = 0;
          for(int i = 0 ; i < colList.length ; i++){
              if(s2.equals(colList[i])){
                  r = 1;
                  break;
              }
              else result++;
          }
          if(r == 0) throw new CustomException.TempException("Where clause try to reference non existing column");
      }

      return result;
  }

  static final public int elementIndexSelect(String[] tableNameList, String s1, String s2) throws UnsupportedEncodingException, CustomException.TempException {
        int result = 0;
        int r = 0;
        String[] colList;

        int c = 0;
        if(s2.equals("")){
            for(int i = 0 ; i < tableNameList.length ; i++){
                colList = findColData(tableNameList[i]);
                for(int j = 0 ; j < colList.length ; j++){
                    if(s1.equals(colList[j])){
                        r = 1;
                        break;
                    }
                    else result++;
                }
                if(r == 1) break;
            }
            if(r == 0) throw new CustomException.TempException("Selection has failed: fail to resolve '" + s1 + "'");

            for(int i = 0 ; i < tableNameList.length ; i++){
                colList = findColData(tableNameList[i]);
                for(int j = 0 ; j < colList.length ; j++){
                    if(s1.equals(colList[j])){
                        c++;
                    }
                }
            }
            if(c > 1) throw new CustomException.TempException("Selection has failed: fail to resolve '" + s1 + "'");
        }
        else{
            r = 0;
            for(int i = 0 ; i < tableNameList.length ; i++){
                if(s1.equals(tableNameList[i])){
                    r = 1;
                    break;
                }
                result += findColData(tableNameList[i]).length;
            }

            if(r == 0) throw new CustomException.TempException("Selection has failed: '" + s1 + "' are not specified");

            colList = findColData(s1);
            r = 0;
            for(int i = 0 ; i < colList.length ; i++){
                if(s2.equals(colList[i])){
                    r = 1;
                    break;
                }
                else result++;
            }
            if(r == 0) throw new CustomException.TempException("Selection has failed: fail to resolve '" + s2 + "'");
        }

        return result;
    }

  static final public int elementIndexWoEx(String[] tableNameList, String s1, String s2) throws UnsupportedEncodingException, CustomException.TempException {
        int result = 0;
        int r = 0;
        String[] colList;

        int c = 0;
        if(s2.equals("")){
            for(int i = 0 ; i < tableNameList.length ; i++){
                colList = findColData(tableNameList[i]);
                for(int j = 0 ; j < colList.length ; j++){
                    if(s1.equals(colList[j])){
                        r = 1;
                        break;
                    }
                    else result++;
                }
                if(r == 1) break;
            }
//            if(r == 0) throw new CustomException.TempException("Where clause try to reference non existing column");
//
//            for(int i = 0 ; i < tableNameList.length ; i++){
//                colList = findColData(tableNameList[i]);
//                for(int j = 0 ; j < colList.length ; j++){
//                    if(s1.equals(colList[j])){
//                        c++;
//                    }
//                }
//            }
//            if(c > 1) throw new CustomException.TempException("Where clause contains ambiguous reference");
        }
        else{
            r = 0;
            for(int i = 0 ; i < tableNameList.length ; i++){
                if(s1.equals(tableNameList[i])){
                    r = 1;
                    break;
                }
                result += findColData(tableNameList[i]).length;
            }
//
//            if(r == 0) throw new CustomException.TempException("Where clause try to tables which are not specified");

            colList = findColData(s1);
            r = 0;
            for(int i = 0 ; i < colList.length ; i++){
                if(s2.equals(colList[i])){
                    r = 1;
                    break;
                }
                else result++;
            }
//            if(r == 0) throw new CustomException.TempException("Where clause try to reference non existing column");
        }

        return result;
    }

  static final public String[] findColData(String tableName) throws UnsupportedEncodingException {
      int num = findTableNumber(tableName);
      String colKey = "column" + num;
      DatabaseEntry key = new DatabaseEntry(colKey.getBytes("UTF-8"));
      DatabaseEntry data = new DatabaseEntry();

      if (myDatabase.get(null, key, data, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
          String result = new String(data.getData(), "UTF-8");
          return result.split(",", -1);
      }
      else {
          System.out.println("No record found for key :" + colKey);
          return null;
      }
  }

  static final public String[] cartesianProduct(String[] tableNameList) throws ParseException, UnsupportedEncodingException {
      String[] tupleList = allTuple(tableNameList[0]);

      for(int i = 1 ; i < tableNameList.length ; i++){
          tupleList = binaryProduct(tupleList, allTuple(tableNameList[i]));
      }

      return tupleList;
  }

  static final public String[] binaryProduct(String[] tupleList1, String[] tupleList2){
      ArrayList<String> result = new ArrayList<>();
      for(int i = 0 ; i < tupleList1.length ; i++){
          for(int j = 0 ; j < tupleList2.length ; j++){
              String element = tupleList1[i] + "," + tupleList2[j];
              result.add(element);
          }
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] allTuple(String tableName) throws ParseException, UnsupportedEncodingException {
      String data = getData("data" + findTableNumber(tableName));
      if(data.equals("")) return new String[0];

      int num = findColData(tableName).length;
      String[] splitData = data.split(",", -1);
      ArrayList<String> result = new ArrayList<>();

      for(int i = 0 ; i < splitData.length ;){
          String tuple = splitData[i++];
          for(int j = 1 ; j < num ; j++){
              tuple += "," + splitData[i++];
          }
          result.add(tuple);
      }

      return result.toArray(new String[result.size()]);
  }

  static final public String[] comparisonPredicate(String[] tableName) throws ParseException, UnsupportedEncodingException, CustomException.TempException {
    String[] tableNameList = tableName[0].split(",", -1);
    String[] tupleList = cartesianProduct(tableNameList);

    Token t1 = comparableValue();
    String op = jj_consume_token(COMP_OP).toString();
    String str1 = "", str2 = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      Token t2 = comparableValue();
      tupleList = filterTuple_comp4(op, tupleList, t1, t2);
      break;
    case LEGAL_IDENTIFIER:
      str1 = jj_consume_token(LEGAL_IDENTIFIER).toString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD:
        str2 = dotColumnName().toString();
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      int idx = elementIndex(tableName, str1, str2);
      tupleList = filterTuple_comp3(op, tupleList, idx, t1);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

    return tupleList;
  }

  static final public Token dotColumnName() throws ParseException, UnsupportedEncodingException {
    jj_consume_token(PERIOD);
    Token t = jj_consume_token(LEGAL_IDENTIFIER);
    return t;
  }

  static final public Token comparableValue() throws ParseException, UnsupportedEncodingException {
    Token t;

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      t = jj_consume_token(INT_VALUE);
      break;
    case CHAR_STRING:
      t = jj_consume_token(CHAR_STRING);
      break;
    case DATE_VALUE:
      t = jj_consume_token(DATE_VALUE);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

    return t;
  }

  static final public void insertQuery() throws ParseException, UnsupportedEncodingException {
    Token t;
    String s;

    jj_consume_token(INSERT_INTO);

    t = jj_consume_token(LEGAL_IDENTIFIER);
    s = t.toString();

    insertColumnsAndSource(s);
  }

  static final public void insertColumnsAndSource(String tableName) throws ParseException, UnsupportedEncodingException {
    String columnNameList = "";
    String valueList = "";
    int num;

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      columnNameList = columnNameList();
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    valueList = valueList();
    String[] values = valueList.split(",", -1);

    jj_consume_token(SEMICOLON);

    if(InsertQueryErrorTest.NoSuchTableError(myDatabase, tableName)) return;

    if(!columnNameList.equals(""))
    {
        if(InsertQueryErrorTest.InsertColumnExistenceError(myDatabase, columnNameList, tableName)) return;
        valueList = ArrangeValues(tableName, columnNameList, values);
    }

    num = findTableNumber(tableName);

    valueList = InsertQueryErrorTest.InsertTruncateCharString(myDatabase, valueList, num);

    if(InsertQueryErrorTest.InsertColumnNonNullableError(myDatabase, valueList, num)) return;
    if(InsertQueryErrorTest.InsertTypeMismatchError(myDatabase, valueList, num)) return;
    if(InsertQueryErrorTest.InsertDuplicatePrimaryKeyError(myDatabase, valueList, num)) return;
    if(InsertQueryErrorTest.InsertReferentialIntegrityError(myDatabase, valueList, num)) return;


    String originalList = getData("data" + num);
    if(!originalList.equals("")) valueList = originalList + "," + valueList;
//    System.out.println(valueList);
    InsertData(num, valueList);

    InsertQueryErrorTest.InsertQuerySuccess();
  }

  static final public void InsertData(int tableNum, String valueList) throws UnsupportedEncodingException{
      String create_key = "data" + tableNum;

      DatabaseEntry key = new DatabaseEntry(create_key.getBytes("UTF-8"));
      DatabaseEntry value = new DatabaseEntry(valueList.getBytes("UTF-8"));
      myDatabase.put(null, key, value);
  }

  static final public String ArrangeValues(String tableName, String columnNameList, String[] value) throws ParseException, UnsupportedEncodingException {
      int num = findTableNumber(tableName);
      String colKey = "column" + num;

      String[] columnData = getData(colKey).split(",", -1);
      String[] columnNames = columnNameList.split(",", -1);
      String result = "";

      for(int i = 0 ; i < columnData.length ; i++){
          String eachValue = value[Arrays.asList(columnNames).indexOf(columnData[i])];
          if(i == 0) result += eachValue;
          else result += "," + eachValue;
      }

      return result;
  }

  static final public String getData(String key) throws UnsupportedEncodingException {
      DatabaseEntry theKey = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry theData = new DatabaseEntry();

      if (myDatabase.get(null, theKey, theData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
          return new String(theData.getData(), "UTF-8");
      } else {
//          System.out.println(key);
          return null;
      }
  }

  static final public String valueList() throws ParseException, UnsupportedEncodingException {
    String result = "";
    String value = "";
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    result += value();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
//      value();
      result += "," + value();
    }
    jj_consume_token(RIGHT_PAREN);

    return result;
  }

  static final public String value() throws ParseException, UnsupportedEncodingException
  {
      Token t;

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      t = jj_consume_token(NULL);
      break;
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      t = comparableValue();
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

    return t.toString();
  }

  static final public void deleteQuery() throws CustomException.TempException, ParseException, UnsupportedEncodingException {
    Token t;
    String s;
    String selectedTuples[];
    jj_consume_token(DELETE_FROM);
    t = jj_consume_token(LEGAL_IDENTIFIER);
    s = t.toString();

    selectedTuples = allTuple(s);

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
        String[] str = new String[2];
        str[0] = s;
        str[1] = "";
      selectedTuples = whereClause(str);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);

    if(DeleteQueryErrorTest.NoSuchTable(s)) return;

    deleteSelectedTuple(s, selectedTuples);
  }

  static final public void deleteSelectedTuple(String tableName, String[] selectedTuples) throws ParseException, UnsupportedEncodingException {
//      String[] resultTuple = negation(tableName, selectedTuples);

      ArrayList<String> tupleToBeDeleted = new ArrayList<>();
      String[] resultTuple;

      int success = 0, fail = 0;
      for(int i = 0 ; i < selectedTuples.length ; i++){
          String tupleElement = tryDelete(tableName, selectedTuples[i]);
          if(tupleElement.equals("")){
              fail++;
          }
          else{
              tupleToBeDeleted.add(tupleElement);
              success++;
          }
      }

      resultTuple = negation(tableName, tupleToBeDeleted.toArray(new String[tupleToBeDeleted.size()]));

      String dataString = resultTuple.length == 0 ? "" : resultTuple[0];
      for(int i = 1 ; i < resultTuple.length ; i++) dataString += "," + resultTuple[i];

      String dataKey = "data" + findTableNumber(tableName);
      DatabaseEntry key = new DatabaseEntry(dataKey.getBytes("UTF-8"));
      DatabaseEntry data = new DatabaseEntry(dataString.getBytes("UTF-8"));
      myDatabase.put(null, key, data);

      System.out.println("DB_2017-17450> " + success + " row(s) are deleted");
      System.out.println("DB_2017-17450> " + fail + " row(s) are not deleted due to referential integrity");
  }

  static final public String tryDelete(String tableName, String tuple) throws UnsupportedEncodingException, ParseException {
      if(DeleteQueryErrorTest.DeleteReferentialIntegrityPassed(tableName, tuple)) return "";
      else return tuple;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public SimpleDBMSParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[32];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1203e20,0x1203e00,0x1203e00,0x0,0xc000000,0x2000000,0xc000000,0x0,0x1c0,0x0,0x8000,0x0,0x4000,0x20000,0x0,0x4000,0x80000,0x100000,0x40000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x800000,0x20000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x1,0x40,0x0,0x0,0x1,0x0,0x1,0x40,0x2,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x2448,0x2,0x2448,0x2,0x2448,0x4100,0x2,0x2448,0x2408,0x0,0x1,0x2408,0x0,};
   }

  /** Constructor with InputStream. */
  public SimpleDBMSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMSParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public SimpleDBMSParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMSParser(SimpleDBMSParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[50];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 32; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 50; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
